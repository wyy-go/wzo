// Code generated by protoc-gen-zoo-errno. DO NOT EDIT.
// versions:
// - protoc-gen-zoo-errno v0.0.1
// - protoc                  v3.17.3
// source: errno.proto

package errno

import (
	fmt "fmt"
	errors "github.com/wyy-go/wzo/core/errors"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = errors.New

type Option interface {
	apply(*errors.Error)
}

type optFunc func(e *errors.Error)

func (o optFunc) apply(e *errors.Error) { o(e) }

func WithMessage(s string) Option {
	return optFunc(func(e *errors.Error) {
		if s != "" {
			e.Message = s
		}
	})
}

func WithDetail(s string) Option {
	return optFunc(func(e *errors.Error) {
		if s != "" {
			e.Detail = s
		}
	})
}

func WithMetadata(k string, v string) Option {
	return optFunc(func(e *errors.Error) {
		if k != "" && v != "" {
			e.Metadata[k] = v
		}
	})
}

func _apply(e *errors.Error, opts ...Option) {
	for _, opt := range opts {
		opt.apply(e)
	}
}

func IsInternalServer(err error) bool {
	e := errors.FromError(err)
	return e.Code == 500
}

func ErrInternalServer(message ...string) *errors.Error {
	if len(message) > 0 {
		return ErrInternalServerw(WithMessage(message[0]))
	}
	return ErrInternalServerw()
}

func ErrInternalServerf(format string, a ...any) *errors.Error {
	return ErrInternalServerw(WithMessage(fmt.Sprintf(format, a...)))
}

func ErrInternalServerw(opt ...Option) *errors.Error {
	e := errors.NewWithStatusCode(500, 500, "服务器错误", ErrorReason_INTERNAL_SERVER.String())
	_apply(e, opt...)
	return e
}
func IsBadRequest(err error) bool {
	e := errors.FromError(err)
	return e.Code == 400
}

func ErrBadRequest(message ...string) *errors.Error {
	if len(message) > 0 {
		return ErrBadRequestw(WithMessage(message[0]))
	}
	return ErrBadRequestw()
}

func ErrBadRequestf(format string, a ...any) *errors.Error {
	return ErrBadRequestw(WithMessage(fmt.Sprintf(format, a...)))
}

func ErrBadRequestw(opt ...Option) *errors.Error {
	e := errors.NewWithStatusCode(500, 400, "请求参数错误", ErrorReason_BAD_REQUEST.String())
	_apply(e, opt...)
	return e
}
func IsTimeout(err error) bool {
	e := errors.FromError(err)
	return e.Code == 1000
}

func ErrTimeout(message ...string) *errors.Error {
	if len(message) > 0 {
		return ErrTimeoutw(WithMessage(message[0]))
	}
	return ErrTimeoutw()
}

func ErrTimeoutf(format string, a ...any) *errors.Error {
	return ErrTimeoutw(WithMessage(fmt.Sprintf(format, a...)))
}

func ErrTimeoutw(opt ...Option) *errors.Error {
	e := errors.NewWithStatusCode(500, 1000, "操作超时", ErrorReason_TIMEOUT.String())
	_apply(e, opt...)
	return e
}
func IsCustom(err error) bool {
	e := errors.FromError(err)
	return e.Code == 1001
}

func ErrCustom(message ...string) *errors.Error {
	if len(message) > 0 {
		return ErrCustomw(WithMessage(message[0]))
	}
	return ErrCustomw()
}

func ErrCustomf(format string, a ...any) *errors.Error {
	return ErrCustomw(WithMessage(fmt.Sprintf(format, a...)))
}

func ErrCustomw(opt ...Option) *errors.Error {
	e := errors.NewWithStatusCode(500, 1001, "自定义错误", ErrorReason_CUSTOM.String())
	_apply(e, opt...)
	return e
}
func IsBizError(err error) bool {
	e := errors.FromError(err)
	return e.Code == 1002
}

func ErrBizError(message ...string) *errors.Error {
	if len(message) > 0 {
		return ErrBizErrorw(WithMessage(message[0]))
	}
	return ErrBizErrorw()
}

func ErrBizErrorf(format string, a ...any) *errors.Error {
	return ErrBizErrorw(WithMessage(fmt.Sprintf(format, a...)))
}

func ErrBizErrorw(opt ...Option) *errors.Error {
	e := errors.NewWithStatusCode(500, 1002, "用户名或密码错误", ErrorReason_BIZ_ERROR.String())
	_apply(e, opt...)
	return e
}
func IsUserOrPasswordIncorrect(err error) bool {
	e := errors.FromError(err)
	return e.Code == 1003
}

func ErrUserOrPasswordIncorrect(message ...string) *errors.Error {
	if len(message) > 0 {
		return ErrUserOrPasswordIncorrectw(WithMessage(message[0]))
	}
	return ErrUserOrPasswordIncorrectw()
}

func ErrUserOrPasswordIncorrectf(format string, a ...any) *errors.Error {
	return ErrUserOrPasswordIncorrectw(WithMessage(fmt.Sprintf(format, a...)))
}

func ErrUserOrPasswordIncorrectw(opt ...Option) *errors.Error {
	e := errors.NewWithStatusCode(500, 1003, "用户名或密码错误", ErrorReason_USER_OR_PASSWORD_INCORRECT.String())
	_apply(e, opt...)
	return e
}
